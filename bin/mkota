#!/bin/bash

# Resolve script directory for bundled resources
SCRIPT_DIR="$(cd -- "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Preserve any environment-provided overrides before sourcing configs
ENV_DEVICE_OVERRIDE="${MKOTA_DEVICE:-}"
ENV_FIRMWARE_OVERRIDE="${MKOTA_FIRMWARE:-}"
ENV_CODENAME_OVERRIDE="${MKOTA_CODENAME:-}"

# Command-line overrides
DEVICE_CLI=""
FIRMWARE_CLI=""
CODENAME_CLI=""

# Configuration file handling
CONFIG_FILE="${MKOTA_CONFIG:-}"
ACTIVE_CONFIG_FILE=""

# Flag for update-binary helper mode
PRINT_UPDATE_BINARY=0

# Positional arguments after option parsing
declare -a POSITIONAL_ARGS=()

# Partition lists
SUPER_PARTITIONS=("system" "vendor" "product" "system_ext" "vendor_dlkm" "odm_dlkm")
SUPER_TR_PARTITIONS=("tr_carrier" "tr_company" "tr_mi" "tr_overlayfs" "tr_preload" "tr_product" "tr_region" "tr_theme")
SYSTEMS=("boot" "dtbo" "vendor_boot" "vbmeta" "vbmeta_system" "vbmeta_vendor")
FIRMWARES=("apusys" "cam_vpu1" "cam_vpu2" "cam_vpu3" "ccu" "dpm" "gpueb" "gz" "lk" "logo" "mcf_ota" "mcupm" "md1img" "mvpu_algo" "pi_img" "preloader_raw" "scp" "spmfw" "sspm" "tee" "tkv" "vcp")

# Log function
log() {
    local type="$1"
    local message="$2"
    case "$type" in
        "INFO") echo -e "${BLUE}[INFO]${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $message" ;;
        "WARNING") echo -e "${YELLOW}[WARNING]${NC} $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
    esac
}

# Error handling function
handle_error() {
    log "ERROR" "$1"
    exit 1
}

usage() {
    cat <<EOF
Usage: $(basename "$0") [options] <work_dir> <tmp_dir>

Options:
  --config <path>    Path to a configuration file exporting DEVICE, FIRMWARE, CODENAME.
  --device <value>   Override device name for this invocation.
  --firmware <value> Override firmware version for this invocation.
  --codename <value> Override device codename for this invocation.
  --print-update-binary [work_dir] [tmp_dir]
                     Print the generated update-binary script to stdout.
  -h, --help         Show this message.

Environment overrides:
  MKOTA_DEVICE                   Override device name.
  MKOTA_FIRMWARE                 Override firmware version.
  MKOTA_CODENAME                 Override device codename.
  MKOTA_CONFIG                   Default configuration file path.
EOF
}

# Check for required tools
check_dependencies() {
    local deps=("zip" "zstd" "du" "cut")
    for dep in "${deps[@]}"; do
        command -v "$dep" >/dev/null 2>&1 || handle_error "$dep is required but not installed. Please install it and try again."
    done
}

# Cleanup function
cleanup() {
    log "INFO" "Cleaning up temporary files..."
    rm -rf "$TMP_DIR"
    log "SUCCESS" "Cleanup completed."
}

parse_global_options() {
    POSITIONAL_ARGS=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --config)
                [[ $# -ge 2 ]] || handle_error "--config requires a path argument"
                CONFIG_FILE="$2"
                shift 2
                ;;
            --device)
                [[ $# -ge 2 ]] || handle_error "--device requires a value"
                DEVICE_CLI="$2"
                shift 2
                ;;
            --firmware)
                [[ $# -ge 2 ]] || handle_error "--firmware requires a value"
                FIRMWARE_CLI="$2"
                shift 2
                ;;
            --codename)
                [[ $# -ge 2 ]] || handle_error "--codename requires a value"
                CODENAME_CLI="$2"
                shift 2
                ;;
            --print-update-binary)
                PRINT_UPDATE_BINARY=1
                shift
                POSITIONAL_ARGS=("$@")
                return
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --)
                shift
                POSITIONAL_ARGS+=("$@")
                return
                ;;
            -*)
                handle_error "Unknown option: $1"
                ;;
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

load_configuration_file() {
    local candidate

    if [[ -n "$CONFIG_FILE" ]]; then
        if [[ -f "$CONFIG_FILE" ]]; then
            ACTIVE_CONFIG_FILE="$CONFIG_FILE"
            # shellcheck disable=SC1090
            source "$CONFIG_FILE"
        else
            handle_error "Configuration file not found: $CONFIG_FILE"
        fi
        return
    fi

    local search_paths=(
        "$PWD/mkota.conf"
        "$SCRIPT_DIR/mkota.conf"
    )

    if [[ -n "${XDG_CONFIG_HOME:-}" ]]; then
        search_paths+=("${XDG_CONFIG_HOME}/mkota/config")
    elif [[ -n "${HOME:-}" ]]; then
        search_paths+=("${HOME}/.config/mkota/config")
    fi

    for candidate in "${search_paths[@]}"; do
        [[ -n "$candidate" && -f "$candidate" ]] || continue
        ACTIVE_CONFIG_FILE="$candidate"
        # shellcheck disable=SC1090
        source "$candidate"
        break
    done
}

apply_configuration_overrides() {
    if [[ -n "$ENV_DEVICE_OVERRIDE" ]]; then
        DEVICE="$ENV_DEVICE_OVERRIDE"
    fi
    if [[ -n "$ENV_FIRMWARE_OVERRIDE" ]]; then
        FIRMWARE="$ENV_FIRMWARE_OVERRIDE"
    fi
    if [[ -n "$ENV_CODENAME_OVERRIDE" ]]; then
        CODENAME="$ENV_CODENAME_OVERRIDE"
    fi

    if [[ -n "$DEVICE_CLI" ]]; then
        DEVICE="$DEVICE_CLI"
    fi
    if [[ -n "$FIRMWARE_CLI" ]]; then
        FIRMWARE="$FIRMWARE_CLI"
    fi
    if [[ -n "$CODENAME_CLI" ]]; then
        CODENAME="$CODENAME_CLI"
    fi

    if [[ -n "$ACTIVE_CONFIG_FILE" ]]; then
        if (( ! PRINT_UPDATE_BINARY )); then
            log "INFO" "Loaded configuration from $ACTIVE_CONFIG_FILE"
        fi
    fi

    [[ -n "${DEVICE:-}" ]] || handle_error "DEVICE is not configured. Use --device, environment variables, or a config file."
    [[ -n "${FIRMWARE:-}" ]] || handle_error "FIRMWARE is not configured. Use --firmware, environment variables, or a config file."
    [[ -n "${CODENAME:-}" ]] || handle_error "CODENAME is not configured. Use --codename, environment variables, or a config file."
}

resolve_directory() {
    local dir="$1"
    [[ -d "$dir" ]] || handle_error "Directory not found: $dir"
    (cd -- "$dir" && pwd -P) || handle_error "Failed to resolve path for: $dir"
}

# Function to convert and compress partition images
convert_partition() {
    local partition="$1"
    log "INFO" "Processing ${partition}.img"
    zstd -T0 "${WORK_DIR}/${partition}.img" -o "$TMP_DIR/${partition}.img.zst" > /dev/null 2>&1 || handle_error "Failed to convert ${partition}.img"
}

# Function to get image size
get_img_size() {
    du -b "$1" | cut -f1
}

generate_update_binary() {
    if [[ -n "$SCRIPT_FOLDER" ]]; then
        mkdir -p "$SCRIPT_FOLDER"
    fi

    # Create the header section of the update script
    cat > "$SCRIPT_FILE" <<'EOF'
#!/sbin/sh

OUTFD=/proc/self/fd/$2
ZIPFILE="$3"

ui_print() {
    printf 'ui_print %s\nui_print\n' "$1" >>"$OUTFD"
}

# Function to extract and flash a file to a partition
flash_partition() {
    src="$1"
    dest="$2"
    msg="$3"

    if [ "$#" -lt 3 ]; then
        partition_name=$(echo "$dest" | cut -d '/' -f 5)
        ui_print "- Flashing partition $partition_name"
    elif [ -n "$msg" ]; then
        ui_print "$msg"
    fi

    unzip -p "$ZIPFILE" "$src" >"$dest"
}

# Function to extract and flash a zstd compressed file to a partition
flash_partition_zstd() {
    src="$1"
    dest="$2"
    partition_name=$(echo "$dest" | cut -d '/' -f 5)

    ui_print "- Flashing partition $partition_name"
    unzip -p "$ZIPFILE" "$src" | /tmp/META-INF/zstd -c -d >"$dest"
}

# Function to flash firmware to both slots while logging once
flash_firmware_both_slots() {
    img_file="$1"
    base_name="$2"

    flash_partition "$img_file" "/dev/block/by-name/${base_name}_a" "- Flashing partition ${base_name} to both slots"
    flash_partition "$img_file" "/dev/block/by-name/${base_name}_b" ""
}

getVolumeKey() {
    ui_print "- Listening to volume keys. Press [+] for 'Yes' and [-] for 'No'"
    keyInfo=true
    while $keyInfo; do
        keyInfo=$(getevent -qlc 1 | grep KEY_VOLUME)
        [ -z "$keyInfo" ] && continue
        isUpKey=$(printf '%s\n' "$keyInfo" | grep KEY_VOLUMEUP)
        [ -n "$isUpKey" ] && return 0 || return 1
        break
    done
}

checkDevice() {
    myDevice=$(getprop ro.product.name)
EOF

    # Add device code verification
    echo "    romDevice=\"$CODENAME\"" >> "$SCRIPT_FILE"

    # Continue with the device verification logic
    cat >> "$SCRIPT_FILE" <<'EOF'
    if [ "$myDevice" != "$romDevice" ]; then
        ui_print "- Device code verification failed. Please double-check if this package matches your device model."
        ui_print "- Flashing the wrong package may cause bricking, and you will bear the consequences. Do you want to continue flashing?"
        if ! getVolumeKey; then
            ui_print "- You chose to abort flashing."
            exit 1
        else
            ui_print "- You chose to continue flashing."
        fi
    fi
}

checkExit() {
    status=$?
    if [ "$status" -ne 0 ]; then
        ui_print "Error: Exit status $status detected. There may be an issue with your super partition. Flash the stock super.img first, then retry. Exiting..."
        exit 1
    fi
}

unmountPartitions() {
    umount system_root vendor product system_ext vendor_dlkm odm_dlkm \
           tr_carrier tr_company tr_mi tr_preload tr_product tr_region tr_theme 2>/dev/null
}

# Function to handle logical partition operations
manage_logical_partition() {
    operation="$1"
    partition="$2"
    size="$3"
    slot="$4"

    case "$operation" in
        clear)
            lptools unmap "$partition$slot" && lptools remove "$partition$slot"
            ;;
        create)
            lptools create "$partition$slot" "$size"
            ;;
        map)
            lptools map "$partition$slot" && checkExit
            ;;
        unmap_map)
            lptools unmap "$partition$slot" && lptools map "$partition$slot"
            ;;
    esac
}

create_partitions_for_slot() {
    target_slot="$1"
    other_slot="$2"
    shift 2

    for spec in "$@"; do
        partition="${spec%%:*}"
        size="${spec#*:}"
        manage_logical_partition "create" "$partition" "$size" "$target_slot"
        manage_logical_partition "create" "$partition" "0" "$other_slot"
    done
}

process_partitions_for_slots() {
    operation="$1"
    shift

    for partition in "$@"; do
        manage_logical_partition "$operation" "$partition" "" "_a"
        manage_logical_partition "$operation" "$partition" "" "_b"
    done
}

unzip "$ZIPFILE" META-INF/zstd -d /tmp
chmod -R 0755 /tmp

ui_print " "
EOF

    cat >> "$SCRIPT_FILE" <<EOF
ui_print "============================================"
ui_print "RRRRR   BBBBB   PPPPP"
ui_print "R   RR  B   BB  P   PP"
ui_print "R   RR  B   BB  P   PP"
ui_print "RRRRR   BBBBB   PPPPP"
ui_print "R RR    B   BB  P"
ui_print "R  RR   B   BB  P"
ui_print "R   RR  BBBBB   P"
ui_print " "
ui_print "Flashable ROM by ramabondanp"
ui_print "Device : $DEVICE"
ui_print "Version: $FIRMWARE"
ui_print "============================================"
EOF

    # Add firmware flashing section
    cat >> "$SCRIPT_FILE" <<'EOF'

checkDevice

unmountPartitions

# Firmware
EOF

    # Add firmware partition flashing commands using the new function
    local firmware_present=0
    for firmware in "${FIRMWARES[@]}"; do
        if [[ -f "${WORK_DIR}/${firmware}.img" ]]; then
            if (( firmware_present == 0 )); then
                echo "ui_print \" \"" >> "$SCRIPT_FILE"
                echo "ui_print \"Patching firmware to both slot...\"" >> "$SCRIPT_FILE"
                firmware_present=1
            fi
            echo "flash_firmware_both_slots \"firmware/${firmware}.img\" \"${firmware}\"" >> "$SCRIPT_FILE"
        fi
    done

    # Add logical partition handling
    cat >> "$SCRIPT_FILE" <<'EOF'

ui_print " "
SLOT=$(getprop ro.boot.slot_suffix)
ui_print "Checking boot slot... ${SLOT}"

# Remap
lptools clear-cow
checkExit

EOF

    # Build arrays of partitions to process with their sizes
    partition_names=()
    partition_specs=()
    for partition in "${SUPER_PARTITIONS[@]}" "${SUPER_TR_PARTITIONS[@]}"; do
        if [[ -f "${WORK_DIR}/${partition}.img" ]]; then
            partition_names+=("${partition}")
            size=$(get_img_size "${WORK_DIR}/${partition}.img")
            partition_specs+=("${partition}:${size}")
        fi
    done

    if ((${#partition_names[@]} > 0)); then
        echo "# Clear existing partitions" >> "$SCRIPT_FILE"
        {
            printf 'process_partitions_for_slots "clear"'
            for partition in "${partition_names[@]}"; do
                printf ' \\%b"%s"' '\n        ' "$partition"
            done
            printf '\n'
        } >> "$SCRIPT_FILE"
    fi

    if ((${#partition_specs[@]} > 0)); then
        echo >> "$SCRIPT_FILE"
        echo "# Create new partitions" >> "$SCRIPT_FILE"

        {
            printf 'case "$SLOT" in\n'
            printf '    "_a") OTHER_SLOT="_b" ;;\n'
            printf '    "_b") OTHER_SLOT="_a" ;;\n'
            printf '    *) ui_print "- Unknown boot slot: $SLOT"; exit 1 ;;\n'
            printf 'esac\n'
            printf '\n'
            printf 'create_partitions_for_slot "$SLOT" "$OTHER_SLOT"'
            for spec in "${partition_specs[@]}"; do
                printf ' \\%b"%s"' '\n        ' "$spec"
            done
            printf '\n'
        } >> "$SCRIPT_FILE"
    fi

    if ((${#partition_names[@]} > 0)); then
        echo >> "$SCRIPT_FILE"
        echo "# Map all partitions" >> "$SCRIPT_FILE"
        {
            printf 'process_partitions_for_slots "map"'
            for partition in "${partition_names[@]}"; do
                printf ' \\%b"%s"' '\n        ' "$partition"
            done
            printf '\n'
        } >> "$SCRIPT_FILE"
    fi

    # Add system flashing section
    echo -e "\nui_print \" \"" >> "$SCRIPT_FILE"
    echo "ui_print \"Patching system...\"" >> "$SCRIPT_FILE"

    # Add system partition flashing commands using the new function
    for system in "${SYSTEMS[@]}"; do
        if [[ -f "${WORK_DIR}/${system}.img" ]]; then
            echo "flash_firmware_both_slots \"${system}.img\" \"${system}\"" >> "$SCRIPT_FILE"
        fi
    done

    # Add zstd compressed partition flashing commands using the new function
    for partition in "${SUPER_PARTITIONS[@]}" "${SUPER_TR_PARTITIONS[@]}"; do
        if [[ -f "${WORK_DIR}/${partition}.img" ]]; then
            echo "flash_partition_zstd \"${partition}.img.zst\" \"/dev/block/mapper/${partition}\$SLOT\"" >> "$SCRIPT_FILE"
        fi
    done

    if ((${#partition_names[@]} > 0)); then
        echo -e "\n# Final unmapping and mapping to ensure proper mounting" >> "$SCRIPT_FILE"
        {
            printf 'process_partitions_for_slots "unmap_map"'
            for partition in "${partition_names[@]}"; do
                printf ' \\%b"%s"' '\n        ' "$partition"
            done
            printf '\n'
        } >> "$SCRIPT_FILE"
    fi

    cat >> "$SCRIPT_FILE" <<EOF

exit 0
EOF
}

print_update_binary() {
    # Use provided work directory and temp dir (arguments take precedence over env vars)
    WORK_DIR="${1:-${WORK_DIR:-}}"
    TMP_DIR="${2:-${TMP_DIR:-}}"
    [[ -n "$WORK_DIR" ]] || handle_error "WORK_DIR must be provided via argument or environment variable"
    [[ -n "$TMP_DIR" ]] || handle_error "TMP_DIR must be provided via argument or environment variable"
    WORK_DIR="$(resolve_directory "$WORK_DIR")"
    SCRIPT_FOLDER=""
    SCRIPT_FILE="/dev/stdout"
    generate_update_binary
}

# Main execution
main() {
    # Directory setup (arguments take precedence over env vars)
    WORK_DIR="${1:-${WORK_DIR:-}}"
    TMP_DIR="${2:-${TMP_DIR:-}}"
    [[ -n "$WORK_DIR" ]] || handle_error "WORK_DIR must be provided via argument or environment variable"
    [[ -n "$TMP_DIR" ]] || handle_error "TMP_DIR must be provided via argument or environment variable"
    WORK_DIR="$(resolve_directory "$WORK_DIR")"
    SCRIPT_FOLDER="${TMP_DIR}/META-INF/com/google/android"
    SCRIPT_FILE="${SCRIPT_FOLDER}/update-binary"
    FIRMWARE_DIR="${TMP_DIR}/firmware"

    # Display banner
    echo -e "\n${BLUE}╔═════════════════════════════════════════════════════════╗${NC}"
    echo -e   "${BLUE}║    Flashable ROM Creation Process Started               ║${NC}"
    echo -e   "${BLUE}║    Device: ${DEVICE}                                    ${NC}"
    echo -e   "${BLUE}║    Firmware: ${FIRMWARE}                                ${NC}"
    echo -e   "${BLUE}║    AutoScript by ramabondanp                            ║${NC}"
    echo -e   "${BLUE}╚═════════════════════════════════════════════════════════╝${NC}\n"

    # Check dependencies
    check_dependencies

    # Create temp directory
    mkdir -p "$TMP_DIR" || handle_error "Failed to create temporary directory"
    mkdir -p "$SCRIPT_FOLDER" || handle_error "Failed to create script folder"

    # Generate update-binary
    log "INFO" "Generating update-binary with improved functions"
    generate_update_binary

    # Convert and compress partition images
    log "INFO" "Converting and compressing partition images"
    for partition in "${SUPER_PARTITIONS[@]}" "${SUPER_TR_PARTITIONS[@]}"; do
        [[ -f "${WORK_DIR}/${partition}.img" ]] && convert_partition "$partition"
    done

    # Copy zstd binary
    # Use bundled arm64 zstd binary
    local zstd_source="${SCRIPT_DIR}/zstd-arm64"
    [[ -f "$zstd_source" ]] || handle_error "Bundled zstd-arm64 binary not found"
    cp "$zstd_source" "$TMP_DIR/META-INF/zstd" || handle_error "Failed to copy zstd binary"
    chmod 0755 "$TMP_DIR/META-INF/zstd" || handle_error "Failed to set permissions on zstd binary"

    # Copy firmware images
    log "INFO" "Copying firmware images"
    local firmware_dir_ready=0
    for firmware in "${FIRMWARES[@]}"; do
        if [[ -f "${WORK_DIR}/${firmware}.img" ]]; then
            if (( firmware_dir_ready == 0 )); then
                mkdir -p "$FIRMWARE_DIR" || handle_error "Failed to create firmware directory"
                firmware_dir_ready=1
            fi
            cp "${WORK_DIR}/${firmware}.img" "$FIRMWARE_DIR" || handle_error "Failed to copy ${firmware}.img"
            log "SUCCESS" "Copied ${firmware}.img"
        else
            log "WARNING" "${firmware}.img not found, skipping"
        fi
    done

    # Copy system images
    log "INFO" "Copying system images"
    for system in "${SYSTEMS[@]}"; do
        if [[ -f "${WORK_DIR}/${system}.img" ]]; then
            cp "${WORK_DIR}/${system}.img" "$TMP_DIR" || handle_error "Failed to copy ${system}.img"
            log "SUCCESS" "Copied ${system}.img"
        else
            log "WARNING" "${system}.img not found, skipping"
        fi
    done

    # Create final ROM zip
    log "INFO" "Creating final ROM zip"
    (cd "$TMP_DIR" && zip -r -n .zst "${WORK_DIR}/${FIRMWARE}-recovery-ab.zip" ./* 2>/dev/null) || handle_error "Failed to create ROM zip"

    # Display completion banner
    echo -e "\n${GREEN}╔════════════════════════════════════════════╗${NC}"
    echo -e   "${GREEN}║  Flashable ROM Creation Process Completed  ║${NC}"
    echo -e   "${GREEN}╚════════════════════════════════════════════╝${NC}\n"

    log "SUCCESS" "ROM creation process completed successfully."
    log "INFO" "ROM zip file: ${WORK_DIR}/${FIRMWARE}-recovery-ab.zip"

    # Clean up temporary files
    cleanup
}

# Entry point
parse_global_options "$@"
set -- "${POSITIONAL_ARGS[@]}"

load_configuration_file
apply_configuration_overrides

if (( PRINT_UPDATE_BINARY )); then
    print_update_binary "$@"
    exit 0
fi

main "$@"
